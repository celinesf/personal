#!/usr/bin/env python
"""
   extract data from natural standart raw file generated by Farzin
   11/12/13 - 0.0.1 : creation
"""
__author__ = "Celine Becquet"
__copyright__ = "Copyright 2013, Viragene Inc."
__maintainer__ = "Celine Becquet"
__email__ = "celine@vitagene.com"
__status__ = "dev" 



PATH = "/Users/Celine/vitagene/script_in_out/ExtractHierarchy"

import logging, copy, json
from SharedFunctions import SharedFunctions

class ExtractHierarchy():
    def __init__(self):
        self.util = SharedFunctions(PATH)
        self.hierarchy = {}
        self.output = {}

    def recover_parents(self, start,info):
        logging.debug(' Function:  recover_parents start: %s , info: %s' %(start,info) )
        parent=[]
        for i in range(0, start):
            parent.append(info[i])
        return parent
    
    def recover_decent(self, info, decent):
        logging.debug(' Function:  recover_decent start: %s , info: %s' %( info, decent) )
        for w in info:
            if w not in decent:
                decent.append(w)
            decent = self.recover_decent(info[w],decent)
        return decent
        
    ### add new term within hierirchy
    def add_term(self, start, info,data):
        logging.debug(' Function:  add_term start: %s , data: %s' %(start, data) )
        if start < len(info):
            if info[start] not in data:
                data[info[start]] = {}
            
            data[info[start]] = self.add_term(start+1, info,copy.deepcopy(data[info[start]]))
            if info[start] not in self.output:
                self.output[info[start]] = {"decent":[],'parent':[]}
                self.output[info[start]]['parent'] = self.recover_parents(start,info)
            self.output[info[start]]["decent"] = self.recover_decent(data[info[start]],self.output[info[start]]["decent"])
            self.output[info[start]]['hierarchy']=data
        return copy.deepcopy(data)
 

    def extract_data(self):
        logging.debug(' Function:  extract_data' )
        infile = open("%s/Natural Standard Traits Hierarchy.txt" % PATH)
        data = infile.readlines()
        record = []
        for line in data:
            l =line.replace("\n","").split('\t')
            for i in range(0,len(l)):
                if l[i] != "" :
                    if i == 0:
                        record = []                        
                    if len(record) == i:
                        record.append(l[i])
                    else:
                        record[i] = l[i]
                        for j in range (i+1,len(record)):
                            record.pop()
                    if len(l) == i+1:
                        self.hierarchy = self.add_term(0,record,copy.deepcopy(self.hierarchy))
                        
                        break
                elif len(record) <=i:
                    self.hierarchy = self.add_term(0,record, copy.deepcopy(self.hierarchy))
                    break
                
                    
        self.util.output_file('hierarchy_map',self.hierarchy)
#         self.util.write_map('hierarchy_map',self.hierarchy)     
        
        self.util.output_file('hierarchy_list',self.output)
#         self.util.write_map('hierarchy_list',self.output)     

        
        infile.close()
                
### main function
if __name__ == "__main__":
    logging.basicConfig(filename='%s/%s' % (PATH,'log_ExtractHierarchy'), filemode='w',
                        level=logging.DEBUG,format='%(asctime)s - %(levelname)s -%(message)s')
    logging.debug(' Function: __main__ input' )
    d = ExtractHierarchy()
    d.extract_data()

    print(' DONE -- Function: __main__' )
    logging.debug(' DONE -- Function: __main__' )
""" END OF main """
