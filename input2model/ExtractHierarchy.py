#!/usr/bin/env python
"""
   extract data from natural standart raw file generated by Farzin
   11/12/13 - 0.0.1 : creation
   01/08/14 - 0.0.2 : add information about key + redundant data -> key will be properly assign when extracting natural standart
"""
__author__ = "Celine Becquet"
__copyright__ = "Copyright 2013, Viragene Inc."
__maintainer__ = "Celine Becquet"
__email__ = "celine@vitagene.com"
__status__ = "dev" 



PATH = "/Users/Celine/vitagene/script_in_out/ExtractHierarchy"

import logging, copy, xlrd, re
from SharedFunctions import SharedFunctions

class ExtractHierarchy():
    def __init__(self):
        self.util = SharedFunctions(PATH)
        self.hierarchy = {}
        self.output = {}
        self.value_key = {}
        self.key_value = {}

    def recover_parents(self, start,info):
        logging.debug(' Function:  recover_parents start: %s , info: %s' %(start,info) )
        parent=[]
        for i in range(0, start):
            parent.append(info[i])
        return parent
    
    def recover_decent(self, info, decent):
        logging.debug(' Function:  recover_decent start: %s , info: %s' %( info, decent) )
        for w in info:
            if w not in decent:
                decent.append(w)
            decent = self.recover_decent(info[w],decent)
        return decent
        
    ### add new term within hierirchy
    def add_term(self, start, info,data):
        logging.debug(' Function:  add_term start: %s , data: %s' %(start, data) )
        if start < len(info):
            if info[start] not in data:
                data[info[start]] = {}
            
            data[info[start]] = self.add_term(start+1, info,copy.deepcopy(data[info[start]]))
            if info[start] not in self.output:
                self.output[info[start]] = {"decent":[],'parent':[]}
                self.output[info[start]]['parent'] = self.recover_parents(start,info)
            self.output[info[start]]["decent"] = self.recover_decent(data[info[start]],self.output[info[start]]["decent"])
            self.output[info[start]]['hierarchy']=data
        return copy.deepcopy(data)
 

    def extract_data(self):
        logging.debug(' Function:  extract_data' )
#         self.extract_redoundancy()
        infile = open("%s/input/Natural Standard Traits Hierarchy.txt" % PATH)
        data = infile.readlines()
        record = []
        for line in data:
            l =line.replace("\n","").split('\t')
            for i in range(0,len(l)):
                if l[i] != "" :
                    if i == 0:
                        record = []                        
                    if len(record) == i:
                        record.append(l[i])
                    else:
                        record[i] = l[i]
                        for j in range (i+1,len(record)):
                            record.pop()
                    if len(l) == i+1:
                        self.hierarchy = self.add_term(0,record,copy.deepcopy(self.hierarchy))
                        break
                elif len(record) <=i:
                    self.hierarchy = self.add_term(0,record, copy.deepcopy(self.hierarchy))
                    break
                
                    
        self.util.output_file('hierarchy_map',self.hierarchy)
#         self.util.write_map('hierarchy_map',self.hierarchy)     
         
        self.util.output_file('hierarchy_list',self.output)
#         self.util.write_map('hierarchy_list',self.output)     

        infile.close()
        
    def extract_redoundancy(self):
        logging.debug(' Function:  extract_redoundancy' )
        infile =  xlrd.open_workbook("%s/input/Natural Standard Traits Map.xlsx" % PATH)
        sheets_names = infile.sheet_names()
        
        for sheet_name in sheets_names:
            sheet = infile.sheet_by_name(sheet_name)
            for nc in range(sheet.ncols):
                column = sheet.col_values(nc)
                key = column[0]
                if key != '':
                    if key not in self.key_value:
                        self.key_value[key] = []
                    for nr in range(1,sheet.nrows):
                        if column[nr] != '':
    #                         print sheet_name, nc, nr,  column[nr]
                            if column[nr] not in self.value_key:
                                self.value_key[column[nr]]= key
                                if column[nr] not in self.key_value[key]:
                                    self.key_value[key].append(column[nr] )
                                else: 
                                    self.util.warnMe('critical', ' EXIST- KEY_VALUE: key %s value %s -values %s' % (key,column[nr],self.key_value[key]))                 
                            else: 
                                self.util.warnMe('critical', ' EXIST- VALUE_KEY: %s %s found as %s' % (key,column[nr], self.value_key[column[nr]]))
                    ### make sure key if also a value
                    if key not in self.key_value[key]:
                        logging.info(' added key %s as value to itself' % key)
                        self.key_value[key].append(key)
                        if key not in self.value_key:
                            logging.info(' added value %s as key to itself' % key)
                            self.value_key[key] = key
                        else:
                            self.util.warnMe('critical', ' why am i here %s' % key)

                    
        self.util.output_file('key_value',self.key_value)
        self.util.output_file('value_key',self.value_key)
              
    def check_data(self):
        logging.debug(' Function:  check_data' )
        self.hierarchy = self.util.get_map('hierarchy_map')
        self.output = self.util.get_map('hierarchy_list')
        self.value_key = self.util.get_map('value_key')
        self.key_value = self.util.get_map('key_value')
        
        ### check all keys are in hierarchy
        key_value_key_not_list = {}
        for key in self.value_key:
            if self.value_key[key] not in self.output:
                if self.value_key[key] not in key_value_key_not_list:
                    key_value_key_not_list[self.value_key[key]] = []
                key_value_key_not_list[self.value_key[key]].append(key)
                logging.error('key_value_key_not_list %s - %s' % (key,self.value_key[key]))
        self.util.output_file('key_value_key_not_list',key_value_key_not_list)
        self.util.write_map('key_value_key_not_list',key_value_key_not_list)
        ### check hierarchy key is in value_key
        key_list_not_value= []
        for key in self.output:
            if key not in self.value_key:
                if key not in key_list_not_value:
                    key_list_not_value.append(key)
                else:
                    self.util.warnMe('critical', ' key_list_not_value %s' % (key))
                logging.error(' key_list_not_value %s ' % (key))
        self.util.output_file('key_list_not_value',key_list_not_value)
        
        ### check hierarchy key is a key 
        key_list_not_key= []
        for key in self.output:
            if key not in self.key_value:
                if key not in key_list_not_key:
                    key_list_not_key.append(key)
                else:
                    self.util.warnMe('critical', ' key_list_not_key %s' % (key))
                logging.error(' key_list_not_key %s ' % (key))
        self.util.output_file('key_list_not_key',key_list_not_key)
        
        ### check key is in hierarchy key 
        key_not_key_list= []
        for key in self.key_value:
            if key not in self.output:
                if key not in key_not_key_list:
                    key_not_key_list.append(key)
                else:
                    self.util.warnMe('critical', ' key_not_key_list %s' % (key))
                logging.error(' key_not_key_list %s ' % (key))
        self.util.output_file('key_not_key_list',key_list_not_key)
        
                
### main function
if __name__ == "__main__":
    logging.basicConfig(filename='%s/%s' % (PATH,'log_ExtractHierarchy-check_data'), filemode='w',
                        level=logging.DEBUG,format='%(asctime)s - %(levelname)s -%(message)s')
    logging.debug(' Function: __main__ input' )
    d = ExtractHierarchy()
#     d.extract_redoundancy()
#     d.extract_data()
#     d.check_data()
  
    
    
    print(' DONE -- Function: __main__' )
    logging.debug(' DONE -- Function: __main__' )
""" END OF main """
